." Text automatically generated by txt2man
.TH "check_commandline" "3m_cli" "July 26, 2020" "" "" " "
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------
.SH NAME
\fB
\fBcheck_commandline(3f) \fP- [ARGUMENTS:M_CLI] check status from READ of NAMELIST group and process pre-defined options
\fB
.SH SYNOPSIS
.nf
.fam C

\fBsubroutine\fP \fBcheck_commandline\fP(ios,message)
.PP
.nf
.fam C
     integer,intent(in)                   :: ios
     character(len=*),intent(in)          :: message
     character(len=*),intent(in),optional :: help_text
     character(len=*),intent(in),optional :: version_text

.fam T
.fi
.fam T
.fi
.SH DESCRIPTION

Essentially a convenience routine for checking the status of a \fBREAD\fP(7f)
of the NAMELIST after calling \fBcommandline\fP(3f). Basically, it lets
you replace
.PP
.nf
.fam C
    if(ios.ne.0)then
       write(*,'("ERROR:",i0,1x,a)')ios, trim(message)
       call print_dictionary('OPTIONS:')
       stop 1
    endif

.fam T
.fi
with
.PP
.nf
.fam C
   call check_commandline(ios,message)

.fam T
.fi
or if the \fB--usage\fP switch is present does
.PP
.nf
.fam C
    if(usage)
       call print_dictionary('OPTIONS:')
    endif

.fam T
.fi
If the optional text values are supplied they will be displayed by \fB--help\fP
and \fB--version\fP command-line options, respectively.
.SS OPTIONS

.TP
.B IOS
status from \fBREAD\fP(7f) of NAMELIST after calling
\fBcommandline\fP(3f)
.TP
.B MESSAGE
message from \fBREAD\fP(7f) of NAMELIST after calling
\fBcommandline\fP(3f)
.TP
.B HELP_TEXT
if present, will be displayed if program is called with
\fB--help\fP switch, and then the program will terminate.
.TP
.B VERSION_TEXT
if present, will be displayed if program is called with
\fB--version\fP switch, and then the program will terminate.
.RS
.PP
If the first four characters of each line are "@(#)" this prefix will
not be displayed. This if for support of the SCCS \fBwhat\fP(1) command. If
you do not have the \fBwhat\fP(1) command on GNU/Linux and Unix platforms
you can probably see how it can be used to place metadata in a binary
by entering:
.PP
.nf
.fam C
        strings demo2|grep '@(#)'|tr '>' '\\n'|sed -e 's/  */ /g'

.fam T
.fi
.SH EXAMPLE
Typical usage:
.PP
.nf
.fam C
    program demo_check_commandline
    use M_CLI,  only : unnamed, commandline, check_commandline
    implicit none
    integer                      :: i
    character(len=255)           :: message ! use for I/O error messages
    character(len=:),allocatable :: readme  ! stores updated namelist
    character(len=:),allocatable :: version_text(:), help_text(:)
    integer                      :: ios

    real               :: x, y, z
    logical            :: help, h
    equivalence       (help,h)
    namelist /args/ x,y,z,help,h
    character(len=*),parameter :: cmd='-x 1 -y 2 -z 3 --help F -h F'

    ! initialize namelist from string and then update from command line
    readme=commandline(cmd)
    !write(*,*)'README=',readme
    read(readme,nml=args,iostat=ios,iomsg=message)
    version_text=[character(len=80) :: "version 1.0","author: me"]
    help_text=[character(len=80) :: "wish I put instructions","here","I suppose?"]
    call check_commandline(ios,message,help_text,version_text)

    ! all done cracking the command line
    ! use the values in your program.
    write(*,nml=args)
    ! the optional unnamed values on the command line are
    ! accumulated in the character array "UNNAMED"
    if(size(unnamed).gt.0)then
       write(*,'(a)')'files:'
       write(*,'(i6.6,3a)')(i,'[',unnamed(i),']',i=1,size(unnamed))
    endif
    end program demo_check_commandline
